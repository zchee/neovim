local t = require('test.unit.testutil')
local itp = t.gen_itp(it)

local C = t.cimport('./src/nvim/tui/tui.h')

describe('tui flush', function()
  itp('skips uv_write when uv_try_write fully flushes output', function()
    local diag = C.nvim_test_tui_flush_diag(16, 16, 0, false, false)
    t.eq(1, tonumber(diag.try_call_count))
    t.eq(0, tonumber(diag.write_call_count))
    t.eq(16, tonumber(diag.try_total))
    t.eq(16, tonumber(diag.try_buf_lens[1]))
    t.eq(0, tonumber(diag.write_total))
  end)

  itp('falls back to uv_write when uv_try_write reports partial progress', function()
    local diag = C.nvim_test_tui_flush_diag(16, 6, 0, false, false)
    t.eq(1, tonumber(diag.try_call_count))
    t.eq(1, tonumber(diag.write_call_count))
    t.eq(16, tonumber(diag.try_total))
    t.eq(10, tonumber(diag.write_total))
    t.eq(10, tonumber(diag.write_buf_lens[1]))
  end)

  itp('handles uv_try_write returning UV_EAGAIN by retrying with uv_write', function()
    local diag = C.nvim_test_tui_flush_diag(12, C.UV_EAGAIN, 0, false, false)
    t.eq(1, tonumber(diag.try_call_count))
    t.eq(1, tonumber(diag.write_call_count))
    t.eq(12, tonumber(diag.write_total))
  end)

  itp('continues on other uv_try_write errors by delegating to uv_write', function()
    local diag = C.nvim_test_tui_flush_diag(8, C.UV_EPIPE, 0, false, false)
    t.eq(1, tonumber(diag.try_call_count))
    t.eq(1, tonumber(diag.write_call_count))
    t.eq(8, tonumber(diag.write_total))
  end)

  itp('avoids IO calls when no payload is queued', function()
    local diag = C.nvim_test_tui_flush_diag(0, 0, 0, false, false)
    t.eq(0, tonumber(diag.try_call_count))
    t.eq(0, tonumber(diag.write_call_count))
    t.eq(false, diag.final_invisible)
  end)
end)
